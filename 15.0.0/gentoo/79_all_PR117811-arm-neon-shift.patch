https://gcc.gnu.org/bugzilla/show_bug.cgi?id=117811#c20

From 5256e5419d07f7313fe661901b9a4821b3d47764 Mon Sep 17 00:00:00 2001
From: Andrew Pinski <quic_apinski@quicinc.com>
Date: Wed, 19 Mar 2025 16:02:12 -0700
Subject: [PATCH] Fix expand_binop_directly in some cases [PR117811]

The problem here is that when dealing with adding the equal note,
we decide to call expand_binop directly but before we do that we
call delete_insns_since with the last argument. The problem is that
deletes too much and falls over. So instead we need to delete only
up to what was done at the point of the call to expand_binop_directly

Bootstrapped and tested on x86_64-linux-gnu.  Also Christophe Lyon tested
it on arm-linux-gnueabihf.

	PR middle-end/117811

gcc/ChangeLog:

	* optabs.cc (expand_binop_directly): Delete only what was done
	since the entry before calling expand_binop.

gcc/testsuite/ChangeLog:

	* c-c++-common/torture/pr117811-1.c: New test.

Signed-off-by: Andrew Pinski <quic_apinski@quicinc.com>
---
 gcc/optabs.cc                                 |  3 +-
 .../c-c++-common/torture/pr117811-1.c         | 32 +++++++++++++++++++
 2 files changed, 34 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/c-c++-common/torture/pr117811-1.c

diff --git a/gcc/optabs.cc b/gcc/optabs.cc
index 36f2e6af8b5..366df985147 100644
--- a/gcc/optabs.cc
+++ b/gcc/optabs.cc
@@ -1380,6 +1380,7 @@ expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,
   rtx_insn *pat;
   rtx xop0 = op0, xop1 = op1;
   bool canonicalize_op1 = false;
+  rtx_insn *entry_last = get_last_insn ();
 
   /* If it is a commutative operator and the modes would match
      if we would swap the operands, we can save the conversions.  */
@@ -1466,7 +1467,7 @@ expand_binop_directly (enum insn_code icode, machine_mode mode, optab binoptab,
 			       optab_to_code (binoptab),
 			       ops[1].value, ops[2].value, mode0))
 	{
-	  delete_insns_since (last);
+	  delete_insns_since (entry_last);
 	  return expand_binop (mode, binoptab, op0, op1, NULL_RTX,
 			       unsignedp, methods);
 	}
diff --git a/gcc/testsuite/c-c++-common/torture/pr117811-1.c b/gcc/testsuite/c-c++-common/torture/pr117811-1.c
new file mode 100644
index 00000000000..a0558cbd0ae
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/torture/pr117811-1.c
@@ -0,0 +1,32 @@
+/* { dg-do run } */
+
+/* PR middle-end/117811 */
+/* Tests that right shift on vectors work. */
+
+typedef int v4 __attribute__((vector_size(4*sizeof(int))));
+
+void buggy_shift( v4 *vec, int shift ) __attribute__((noipa));
+void buggy_shift( v4 *vec, int shift )
+{
+  v4 t = *vec;
+
+  if ( shift > 0 )
+  {
+    t = t >> shift;
+  }
+
+  *vec = t;
+}
+
+int main()
+{
+  v4 v = {0x0<<4, 0x1<<4, 2<<4, 3<<4};
+  v4 r = {0x0, 0x1, 2, 3};
+  int shift = 4;
+  buggy_shift(&v, shift);
+  for(int i = 0; i < 4; i++)
+    if (v[i] != r[i])
+      __builtin_abort();
+  return 0;
+}
+
-- 
2.43.0

