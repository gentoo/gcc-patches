https://inbox.sourceware.org/gcc-patches/2760830.lGaqSPkdTl@fomalhaut/

Boolean types can have precision > 1 so using !undefined_p && !varying_p is
not sufficient for them:

// Types of value ranges.
enum value_range_kind
{
  /* Empty range.  */
  VR_UNDEFINED,
  /* Range spans the entire domain.  */
  VR_VARYING,
  /* Range is [MIN, MAX].  */
  VR_RANGE,
  /* Range is ~[MIN, MAX].  */
  VR_ANTI_RANGE,
  /* Range is a NAN.  */
  VR_NAN,
  /* Range is a nice guy.  */
  VR_LAST
};

Breakpoint 1, simplify_using_initial_conditions (loop=0x7ffff5a09af0,
    expr=0x7ffff5a69960)
    at /home/eric/gnat/gnat-head/src/gcc/tree-ssa-loop-niter.cc:3095
3095        return expr_range.nonzero_p () ? boolean_true_node :
boolean_false_node;
(types__TintB) opt__maximum_file_name_length.26_178 + -2 > flength_272
(gdb) p debug (expr_range)
[irange] boolean [0, 1]
(gdb) call expr_range.varying_p ()
$95 = false

Tested on x86-64/Linux, OK for the mainline?


	PR tree-optimization/122934
	* tree-ssa-loop-niter.cc (simplify_using_initial_conditions): Use
	singleton_p predicate even with boolean ranges.
--- a/gcc/tree-ssa-loop-niter.cc
+++ b/gcc/tree-ssa-loop-niter.cc
@@ -3086,13 +3086,13 @@ simplify_using_initial_conditions (class loop *loop, tree expr)
     return expr;
 
   value_range expr_range (TREE_TYPE (expr));
+  tree val;
   if (TREE_TYPE (expr) == boolean_type_node
       && get_range_query (cfun)->range_on_edge (expr_range,
 						loop_preheader_edge (loop),
 						expr)
-      && !expr_range.undefined_p ()
-      && !expr_range.varying_p ())
-    return expr_range.nonzero_p () ? boolean_true_node : boolean_false_node;
+      && expr_range.singleton_p (&val))
+    return val;
 
   backup = expanded = expand_simple_operations (expr);
 
