https://gcc.gnu.org/bugzilla/show_bug.cgi?id=121572#c6

From 27d463bd32623918d641a4f5168811ae86939e9b Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Sat, 16 Aug 2025 14:04:33 -0700
Subject: [PATCH] x86: Place the TLS call before all register setting BBs

We can't place a TLS call before a conditional jump in a basic block like

(code_label 13 11 14 4 2 (nil) [1 uses])
(note 14 13 16 4 [bb 4] NOTE_INSN_BASIC_BLOCK)
(jump_insn 16 14 17 4 (set (pc)
        (if_then_else (le (reg:CCNO 17 flags)
                (const_int 0 [0]))
            (label_ref 27)
            (pc))) "x.c":10:21 discrim 1 1462 {*jcc}
     (expr_list:REG_DEAD (reg:CCNO 17 flags)
        (int_list:REG_BR_PROB 628353713 (nil)))
 -> 27)

since the TLS call will clobber flags register nor place a TLS call in a
basic block if any live caller-saved registers aren't dead at the end of
the basic block:

;; live  in      6 [bp] 7 [sp] 16 [argp] 17 [flags] 19 [frame] 104
;; live  gen     0 [ax] 102 106 108 116 117 118 120
;; live  kill    5 [di]

Instead, we should place such call before all register setting basic
blocks which dominate the current basic block.

NB: GNU2 TLS:

(insn 66 2 5 2 (parallel [
  (set (reg:DI 116)
       (plus:DI (unspec:DI [
                   (symbol_ref:DI ("_TLS_MODULE_BASE_") [flags 0x10])
                   (unspec:DI [
                      (symbol_ref:DI ("_TLS_MODULE_BASE_") [flags 0x10])
                    ] UNSPEC_TLSDESC)
                   (reg/f:DI 7 sp)] UNSPEC_TLSDESC)
                (const:DI (unspec:DI [
                            (symbol_ref:DI ("tv_cache") [flags 0x5a])
                           ] UNSPEC_DTPOFF))))
  (clobber (reg:CC 17 flags))]) 1678 {*tls_dynamic_gnu2_combine_64_di}
  (nil))

only clobbers flags register.

gcc/

	PR target/121572
	* config/i386/i386-features.cc (ix86_get_dominator_for_reg): New.
	(ix86_place_single_tls_call): Add the live flag register to the
	bitmap.  Clear the live register bitmap only for hard register.
	If there is a conditional jump in the basic block or any live
	caller-saved registers aren't dead at the end of the basic block,
	get the basic block which dominates all basic blocks which set
	the live registers.

gcc/testsuite/

	PR target/121572
	* gcc.target/i386/pr121572-1a.c: New test.
	* gcc.target/i386/pr121572-1b.c: Likewise.
	* gcc.target/i386/pr121572-2a.c: Likewise.
	* gcc.target/i386/pr121572-2b.c: Likewise.

Signed-off-by: H.J. Lu <hjl.tools@gmail.com>
---
 gcc/config/i386/i386-features.cc            | 77 ++++++++++++++++-----
 gcc/testsuite/gcc.target/i386/pr121572-1a.c | 41 +++++++++++
 gcc/testsuite/gcc.target/i386/pr121572-1b.c | 18 +++++
 gcc/testsuite/gcc.target/i386/pr121572-2a.c | 55 +++++++++++++++
 gcc/testsuite/gcc.target/i386/pr121572-2b.c | 17 +++++
 5 files changed, 192 insertions(+), 16 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/i386/pr121572-1a.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr121572-1b.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr121572-2a.c
 create mode 100644 gcc/testsuite/gcc.target/i386/pr121572-2b.c

diff --git a/gcc/config/i386/i386-features.cc b/gcc/config/i386/i386-features.cc
index f0bdc5c1880..235c255232a 100644
--- a/gcc/config/i386/i386-features.cc
+++ b/gcc/config/i386/i386-features.cc
@@ -3732,6 +3732,33 @@ replace_tls_call (rtx src, auto_bitmap &tls_call_insns)
     }
 }
 
+/* Return the basic block which dominates all basic blocks which set
+   hard register REGNO used in basic block BB.  */
+
+static basic_block
+ix86_get_dominator_for_reg (unsigned int regno, basic_block bb)
+{
+  basic_block set_bb;
+  auto_bitmap set_bbs;
+
+  /* Get all BBs which set REGNO and dominate the current BB from all
+     DEFs of REGNO.  */
+  for (df_ref def = DF_REG_DEF_CHAIN (regno);
+       def;
+       def = DF_REF_NEXT_REG (def))
+    if (!DF_REF_IS_ARTIFICIAL (def)
+	&& !DF_REF_FLAGS_IS_SET (def, DF_REF_MAY_CLOBBER)
+	&& !DF_REF_FLAGS_IS_SET (def, DF_REF_MUST_CLOBBER))
+      {
+	set_bb = DF_REF_BB (def);
+	if (dominated_by_p (CDI_DOMINATORS, bb, set_bb))
+	  bitmap_set_bit (set_bbs, set_bb->index);
+      }
+
+  bb = nearest_common_dominator_for_set (CDI_DOMINATORS, set_bbs);
+  return bb;
+}
+
 /* Generate a TLS call of KIND with VAL and copy the call result to DEST,
    at entry of the nearest dominator for basic block map BBS, which is in
    the fake loop that contains the whole function, so that there is only
@@ -3748,6 +3775,7 @@ ix86_place_single_tls_call (rtx dest, rtx val, x86_cse_kind kind,
     bb = get_immediate_dominator (CDI_DOMINATORS,
 				  bb->loop_father->header);
 
+place_tls_call:
   rtx_insn *insn = BB_HEAD (bb);
   while (insn && !NONDEBUG_INSN_P (insn))
     {
@@ -3824,7 +3852,8 @@ ix86_place_single_tls_call (rtx dest, rtx val, x86_cse_kind kind,
   auto_bitmap live_caller_saved_regs;
   bitmap in = df_live ? DF_LIVE_IN (bb) : DF_LR_IN (bb);
 
-  bool flags_live_p = bitmap_bit_p (in, FLAGS_REG);
+  if (bitmap_bit_p (in, FLAGS_REG))
+    bitmap_set_bit (live_caller_saved_regs, FLAGS_REG);
 
   unsigned int i;
 
@@ -3845,13 +3874,28 @@ ix86_place_single_tls_call (rtx dest, rtx val, x86_cse_kind kind,
 	  if (!NONDEBUG_INSN_P (insn))
 	    continue;
 
+	  if (JUMP_P (insn))
+	    {
+	      /* This must be a conditional jump.  */
+	      rtx label = JUMP_LABEL (insn);
+	      if (label == nullptr
+		  || ANY_RETURN_P (label)
+		  || !(LABEL_P (label) || SYMBOL_REF_P (label)))
+		gcc_unreachable ();
+
+	      /* Place the call before all FLAGS_REG setting BBs since
+		 we can't place a call before nor after a conditional
+		 jump.  */
+	      break;
+	    }
+
 	  /* Check if FLAGS register is live.  */
 	  set = single_set (insn);
 	  if (set)
 	    {
 	      rtx dest = SET_DEST (set);
 	      if (REG_P (dest) && REGNO (dest) == FLAGS_REG)
-		flags_live_p = true;
+		bitmap_set_bit (live_caller_saved_regs, FLAGS_REG);
 	    }
 
 	  rtx link;
@@ -3863,29 +3907,30 @@ ix86_place_single_tls_call (rtx dest, rtx val, x86_cse_kind kind,
 		for (i = REGNO (XEXP (link, 0));
 		     i < END_REGNO (XEXP (link, 0));
 		     i++)
-		  bitmap_clear_bit (live_caller_saved_regs, i);
-
-		/* Check if FLAGS register is dead.  */
-		if (REGNO (XEXP (link, 0)) == FLAGS_REG)
-		  flags_live_p = false;
+		  if (i < FIRST_PSEUDO_REGISTER)
+		    bitmap_clear_bit (live_caller_saved_regs, i);
 
 		if (bitmap_empty_p (live_caller_saved_regs))
 		  {
-		    /* All live caller-saved registers are dead after
-		       this instruction.  Since TLS instructions
-		       clobber FLAGS register, it must be dead where
-		       the TLS will be inserted after.  */
-		    if (flags_live_p)
-		      gcc_unreachable ();
 		    after = insn;
 		    goto insert_after;
 		  }
 	      }
 	}
 
-      /* All live caller-saved registers should be dead at the end
-	 of this basic block.  */
-      gcc_unreachable ();
+      /* If any live caller-saved registers aren't dead at the end
+	 of this basic block, get the basic block which dominates all
+	 basic blocks which set the remaining live registers.  */
+      auto_bitmap set_bbs;
+      bitmap_iterator bi;
+      unsigned int id;
+      EXECUTE_IF_SET_IN_BITMAP (live_caller_saved_regs, 0, id, bi)
+	{
+	  basic_block set_bb = ix86_get_dominator_for_reg (id, bb);
+	  bitmap_set_bit (set_bbs, set_bb->index);
+	}
+      bb = nearest_common_dominator_for_set (CDI_DOMINATORS, set_bbs);
+      goto place_tls_call;
     }
 
   /* Emit the TLS CALL insn.  */
diff --git a/gcc/testsuite/gcc.target/i386/pr121572-1a.c b/gcc/testsuite/gcc.target/i386/pr121572-1a.c
new file mode 100644
index 00000000000..270d8ff5cb6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr121572-1a.c
@@ -0,0 +1,41 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O0 -fpic -fplt -mtls-dialect=gnu" } */
+/* Keep labels and directives ('.cfi_startproc', '.cfi_endproc').  */
+/* { dg-final { check-function-bodies "**" "" "" { target { ! ia32 } } {^\t?\.} } } */
+
+/*
+**bug:
+**.LFB[0-9]+:
+**...
+**	leaq	tv_cache@tlsld\(%rip\), %rdi
+**	call	__tls_get_addr@PLT
+**	movl	\$-1, %edi
+**	mov[l|q]	%[e|r]ax, %[e|r]bx
+**	call	val@PLT
+**...
+*/
+
+extern __thread int tv_cache __attribute__ ((visibility ("hidden")));
+extern void use_cache (int);
+extern int val (int v);
+
+__attribute__ ((optimize (2)))
+void
+bug (void)
+{
+  int compared = val (-1);
+
+  if (compared == 0 || (compared > 0 && val (2) == 0))
+    {
+      __builtin_trap ();
+    }
+
+  if (compared < 0)
+    {
+      use_cache (tv_cache);
+      return;
+    }
+
+  use_cache (tv_cache);
+  __builtin_trap ();
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr121572-1b.c b/gcc/testsuite/gcc.target/i386/pr121572-1b.c
new file mode 100644
index 00000000000..8a6089109f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr121572-1b.c
@@ -0,0 +1,18 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O0 -fpic -fplt -mtls-dialect=gnu2" } */
+/* Keep labels and directives ('.cfi_startproc', '.cfi_endproc').  */
+/* { dg-final { check-function-bodies "**" "" "" { target { ! ia32 } } {^\t?\.} } } */
+
+/*
+**bug:
+**.LFB[0-9]+:
+**...
+**	lea[l|q]	tv_cache@TLSDESC\(%rip\), %[e|r]ax
+**	movl	\$-1, %edi
+**	call	\*tv_cache@TLSCALL\(%[e|r]ax\)
+**	mov[l|q]	%[e|r]ax, %[e|r]bx
+**	call	val@PLT
+**...
+*/
+
+#include "pr121572-1a.c"
diff --git a/gcc/testsuite/gcc.target/i386/pr121572-2a.c b/gcc/testsuite/gcc.target/i386/pr121572-2a.c
new file mode 100644
index 00000000000..3f2230f8885
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr121572-2a.c
@@ -0,0 +1,55 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O2 -fpic -fplt -mtls-dialect=gnu" } */
+/* Keep labels and directives ('.cfi_startproc', '.cfi_endproc').  */
+/* { dg-final { check-function-bodies "**" "" "" { target { ! ia32 } } {^\t?\.} } } */
+
+/*
+**mpfr_agm:
+**.LFB[0-9]+:
+**...
+**	movl	%edi, %ebp
+**	data16	leaq	__gmpfr_emax@tlsgd\(%rip\), %rdi
+**	.value	0x6666
+**	rex64
+**	call	__tls_get_addr@PLT
+**	mov[l|q]	mpfr_agm_compare@GOTPCREL\(%rip\), %[e|r]dx
+**	movl	\(%[e|r]dx\), %edx
+**	testl	%edx, %edx
+**	je	.L2
+**...
+*/
+
+typedef enum
+{
+  MPFR_RNDN
+} mpfr_rnd_t;
+typedef int mpfr_t[1];
+long __gmpfr_emin, mpfr_agm_expo_0;
+_Thread_local long __gmpfr_emax;
+int mpfr_agm_compare, mpfr_agm___trans_tmp_1;
+mpfr_t mpfr_agm_u;
+void mpfr_mul (int *, int, int, mpfr_rnd_t);
+int
+mpfr_agm (int op1)
+{
+  int op2 = 0;
+  if (__builtin_expect (mpfr_agm_compare == 0, 0))
+    return 0;
+  if (mpfr_agm_compare > 0)
+    {
+      int t = op1;
+      op2 = t;
+    }
+  mpfr_agm_expo_0 = __gmpfr_emax;
+  for (;;)
+    {
+    retry:
+      mpfr_mul (mpfr_agm_u, op1, op2, MPFR_RNDN);
+      if (0)
+        goto retry;
+      if (__builtin_expect (mpfr_agm___trans_tmp_1, 1))
+        break;
+    }
+  __gmpfr_emin = __gmpfr_emax;
+  return 0;
+}
diff --git a/gcc/testsuite/gcc.target/i386/pr121572-2b.c b/gcc/testsuite/gcc.target/i386/pr121572-2b.c
new file mode 100644
index 00000000000..d81e2edc6f2
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/pr121572-2b.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target *-*-linux* } } */
+/* { dg-options "-O2 -fpic -fplt -mtls-dialect=gnu2" } */
+/* Keep labels and directives ('.cfi_startproc', '.cfi_endproc').  */
+/* { dg-final { check-function-bodies "**" "" "" { target { ! ia32 } } {^\t?\.} } } */
+
+/*
+**mpfr_agm:
+**.LFB[0-9]+:
+**	.cfi_startproc
+**	sub[l|q]	\$[0-9]+, %[e|r]sp
+**	.cfi_def_cfa_offset [0-9]+
+**	lea[l|q]	__gmpfr_emax@TLSDESC\(%rip\), %[e|r]ax
+**	call	\*__gmpfr_emax@TLSCALL\(%[e|r]ax\)
+**...
+*/
+
+#include "pr121572-2a.c"
-- 
2.50.1
