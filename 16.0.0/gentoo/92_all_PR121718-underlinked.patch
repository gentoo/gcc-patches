From 8ed3eaa75908ec5ddb364625e05b3bcac5765a25 Mon Sep 17 00:00:00 2001
Message-ID: <8ed3eaa75908ec5ddb364625e05b3bcac5765a25.1756512714.git.sam@gentoo.org>
From: Sam James <sam@gentoo.org>
Date: Sat, 30 Aug 2025 01:11:52 +0100
Subject: [PATCH] Revert "Fix _Decimal128 arithmetic error under FE_UPWARD."

This reverts commit 50064b2898edfb83bc37f2597a35cbd3c1c853e3.
---
 gcc/testsuite/gcc.target/i386/pr120691.c |  18 -
 libgcc/config/libbid/bid128_div.c        | 135 +-----
 libgcc/config/libbid/bid128_rem.c        |  34 --
 libgcc/config/libbid/bid128_sqrt.c       |  43 +-
 libgcc/config/libbid/bid64_div.c         | 530 +++++++++--------------
 libgcc/config/libbid/bid64_sqrt.c        |  41 +-
 6 files changed, 215 insertions(+), 586 deletions(-)
 delete mode 100644 gcc/testsuite/gcc.target/i386/pr120691.c
 mode change 100755 => 100644 libgcc/config/libbid/bid128_div.c
 mode change 100755 => 100644 libgcc/config/libbid/bid128_rem.c
 mode change 100755 => 100644 libgcc/config/libbid/bid128_sqrt.c
 mode change 100755 => 100644 libgcc/config/libbid/bid64_div.c
 mode change 100755 => 100644 libgcc/config/libbid/bid64_sqrt.c

diff --git a/gcc/testsuite/gcc.target/i386/pr120691.c b/gcc/testsuite/gcc.target/i386/pr120691.c
deleted file mode 100644
index 241a34faa457..000000000000
--- a/gcc/testsuite/gcc.target/i386/pr120691.c
+++ /dev/null
@@ -1,18 +0,0 @@
-/* { dg-do run { target { ! ia32 } } } */
-/* { dg-options "-O0 -mfpmath=sse" } */
-/* { dg-require-effective-target fenv } */
-/* { dg-require-effective-target dfp } */
-
-#include <fenv.h>
-
-int   main()   {
-  fesetround( FE_UPWARD );
-  _Decimal128   x1 =  9825,  x2 =  10000 ;
-
-  double c = (double) (x1 / x2);
-
-  if (c != 0.9825)
-    __builtin_abort ();
-
-  return   0 ;
-}
diff --git a/libgcc/config/libbid/bid128_div.c b/libgcc/config/libbid/bid128_div.c
old mode 100755
new mode 100644
index 04955f27d38d..925bf14a3361
--- a/libgcc/config/libbid/bid128_div.c
+++ b/libgcc/config/libbid/bid128_div.c
@@ -24,16 +24,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define BID_128RES
 #include "bid_div_macros.h"
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
+#include <fenv.h>
+
 #define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT
 #endif
-#include <stdio.h>
-#include <fenv.h>
 
 extern UINT32 convert_table[5][128][2];
 extern SINT8 factors[][2];
 extern UINT8 packed_10000_zeros[];
 
-
 BID128_FUNCTION_ARG2 (bid128_div, x, y)
 
      UINT256 CA4, CA4r, P256;
@@ -46,18 +45,10 @@ BID128_FUNCTION_ARG2 (bid128_div, x, y)
        digits_q, amount;
      int nzeros, i, j, k, d5;
      unsigned rmode;
-     int old_rm, rm_changed=0;
-
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
      fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-  
 valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);
 
   // unpack arguments, check for NaN or Infinity
@@ -71,8 +62,6 @@ if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {
 #endif
   res.w[1] = (CX.w[1]) & QUIET_MASK64;
   res.w[0] = CX.w[0];
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
     // x is Infinity?
@@ -86,8 +75,6 @@ if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
 #endif
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is NaN?
@@ -98,8 +85,6 @@ if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
     res.w[1] = ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) |
       0x7800000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -112,8 +97,6 @@ if ((y.w[1] & 0x7800000000000000ull) < 0x7800000000000000ull) {
     // x=y=0, return NaN
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // return 0
@@ -125,8 +108,6 @@ if ((y.w[1] & 0x7800000000000000ull) < 0x7800000000000000ull) {
     exponent_x = 0;
   res.w[1] |= (((UINT64) exponent_x) << 49);
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 }
@@ -141,8 +122,6 @@ if (!valid_y) {
 #endif
     res.w[1] = CY.w[1] & QUIET_MASK64;
     res.w[0] = CY.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is Infinity?
@@ -150,8 +129,6 @@ if (!valid_y) {
     // return +/-0
     res.w[1] = sign_x ^ sign_y;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0, return +/-Inf
@@ -161,8 +138,6 @@ if (!valid_y) {
   res.w[1] =
     ((x.w[1] ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -211,8 +186,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // get number of decimal digits in CQ
@@ -406,8 +379,6 @@ if (!CA4.w[0] && !CA4.w[1])
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #endif
@@ -498,8 +469,6 @@ if (diff_expon >= 0) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 
 }
@@ -508,8 +477,6 @@ get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
 
@@ -529,17 +496,10 @@ TYPE0_FUNCTION_ARGTYPE1_ARGTYPE2 (UINT128, bid128dd_div, UINT64, x,
        digits_q, amount;
      int nzeros, i, j, k, d5;
      unsigned rmode;
-     int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
      fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 valid_y = unpack_BID64 (&sign_y, &exponent_y, &CY.w[0], y);
 
 	// unpack arguments, check for NaN or Infinity
@@ -559,8 +519,6 @@ if ((x & NAN_MASK64) == NAN_MASK64) {
   res.w[0] = (CX.w[0] & 0x0003ffffffffffffull);
   __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);
   res.w[1] |= ((CX.w[0]) & 0xfc00000000000000ull);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 	   // x is Infinity?
@@ -574,17 +532,13 @@ if (((x) & 0x7800000000000000ull) == 0x7800000000000000ull) {
 #endif
   res.w[1] = 0x7c00000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
-  BID_RETURN (res);
+    BID_RETURN (res);
   }
   if ((((y) & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
   // otherwise return +/-Inf
   res.w[1] =
     (((x) ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
   }
 }
@@ -597,8 +551,6 @@ if ((((y) & 0x7800000000000000ull) != 0x7800000000000000ull)) {
   // x=y=0, return NaN
   res.w[1] = 0x7c00000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 	   // return 0
@@ -614,8 +566,6 @@ else if (exponent_x < 0)
   exponent_x = 0;
 res.w[1] |= (((UINT64) exponent_x) << 49);
 res.w[0] = 0;
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
 }
@@ -633,17 +583,13 @@ if (!valid_y) {
   res.w[0] = (CY.w[0] & 0x0003ffffffffffffull);
   __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);
   res.w[1] |= ((CY.w[0]) & 0xfc00000000000000ull);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
-  BID_RETURN (res);
+    BID_RETURN (res);
   }
   // y is Infinity?
   if (((y) & 0x7800000000000000ull) == 0x7800000000000000ull) {
     // return +/-0
     res.w[1] = sign_x ^ sign_y;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0, return +/-Inf
@@ -653,8 +599,6 @@ if (!valid_y) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -703,8 +647,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // get number of decimal digits in CQ
@@ -901,8 +843,6 @@ __div_256_by_128 (&CQ, &CA4, CY);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 #endif
@@ -992,8 +932,6 @@ if (diff_expon >= 0) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 
 }
@@ -1002,8 +940,6 @@ get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
 
@@ -1019,17 +955,10 @@ BID128_FUNCTION_ARGTYPE1_ARG128 (bid128dq_div, UINT64, x, y)
        digits_q, amount;
      int nzeros, i, j, k, d5;
      unsigned rmode;
-     int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
      fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);
 
 	// unpack arguments, check for NaN or Infinity
@@ -1049,8 +978,6 @@ if ((x & NAN_MASK64) == NAN_MASK64) {
   res.w[0] = (CX.w[0] & 0x0003ffffffffffffull);
   __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);
   res.w[1] |= ((CX.w[0]) & 0xfc00000000000000ull);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 	   // x is Infinity?
@@ -1064,8 +991,6 @@ if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {
 #endif
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
@@ -1073,8 +998,6 @@ if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {
   res.w[1] =
     ((x ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
   }
 }
@@ -1087,8 +1010,6 @@ if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) {
     // x=y=0, return NaN
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // return 0
@@ -1100,8 +1021,6 @@ if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) {
     exponent_x = 0;
   res.w[1] |= (((UINT64) exponent_x) << 49);
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 }
@@ -1118,8 +1037,6 @@ if (!valid_y) {
 #endif
     res.w[1] = CY.w[1] & QUIET_MASK64;
     res.w[0] = CY.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is Infinity?
@@ -1127,8 +1044,6 @@ if (!valid_y) {
     // return +/-0
     res.w[1] = sign_x ^ sign_y;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0, return +/-Inf
@@ -1138,8 +1053,6 @@ if (!valid_y) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -1188,8 +1101,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // get number of decimal digits in CQ
@@ -1389,8 +1300,6 @@ __div_256_by_128 (&CQ, &CA4, CY);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 #endif
@@ -1480,8 +1389,6 @@ if (diff_expon >= 0) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 
@@ -1489,8 +1396,6 @@ get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 
 }
@@ -1506,16 +1411,10 @@ BID128_FUNCTION_ARG128_ARGTYPE2 (bid128qd_div, x, UINT64, y)
      int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,
        digits_q, amount;
      int nzeros, i, j, k, d5, rmode;
-     int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
      fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
 
 valid_y = unpack_BID64 (&sign_y, &exponent_y, &CY.w[0], y);
 	// unpack arguments, check for NaN or Infinity
@@ -1529,8 +1428,6 @@ if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {
 #endif
   res.w[1] = (CX.w[1]) & QUIET_MASK64;
   res.w[0] = CX.w[0];
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
     // x is Infinity?
@@ -1544,8 +1441,6 @@ if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
 #endif
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is NaN?
@@ -1556,8 +1451,6 @@ if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
     res.w[1] = ((x.w[1] ^ y) & 0x8000000000000000ull) |
       0x7800000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -1570,8 +1463,6 @@ if ((y & 0x7800000000000000ull) < 0x7800000000000000ull) {
     // x=y=0, return NaN
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // return 0
@@ -1583,8 +1474,6 @@ if ((y & 0x7800000000000000ull) < 0x7800000000000000ull) {
     exponent_x = 0;
   res.w[1] |= (((UINT64) exponent_x) << 49);
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 }
@@ -1601,17 +1490,13 @@ if (!valid_y) {
   res.w[0] = (CY.w[0] & 0x0003ffffffffffffull);
   __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);
   res.w[1] |= ((CY.w[0]) & 0xfc00000000000000ull);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
-  BID_RETURN (res);
+    BID_RETURN (res);
   }
   // y is Infinity?
   if ((y & INFINITY_MASK64) == INFINITY_MASK64) {
     // return +/-0
     res.w[1] = ((x.w[1] ^ y) & 0x8000000000000000ull);
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0
@@ -1620,8 +1505,6 @@ if (!valid_y) {
 #endif
   res.w[1] = (sign_x ^ sign_y) | INFINITY_MASK64;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -1670,8 +1553,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // get number of decimal digits in CQ
@@ -1868,8 +1749,6 @@ __div_256_by_128 (&CQ, &CA4, CY);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 #endif
@@ -1959,8 +1838,6 @@ if (diff_expon >= 0) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 
 }
@@ -1969,8 +1846,6 @@ get_BID128 (&res, sign_x ^ sign_y, diff_expon, CQ, &rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 
 }
diff --git a/libgcc/config/libbid/bid128_rem.c b/libgcc/config/libbid/bid128_rem.c
old mode 100755
new mode 100644
index 68a88d25234f..f229b2869af3
--- a/libgcc/config/libbid/bid128_rem.c
+++ b/libgcc/config/libbid/bid128_rem.c
@@ -23,7 +23,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #define BID_128RES
 #include "bid_div_macros.h"
-#include <fenv.h>
 
 
 BID128_FUNCTION_ARG2_NORND_CUSTOMRESTYPE (UINT128, bid128_rem, x, y)
@@ -35,16 +34,9 @@ BID128_FUNCTION_ARG2_NORND_CUSTOMRESTYPE (UINT128, bid128_rem, x, y)
      int_float f64, fx;
      int exponent_x, exponent_y, diff_expon, bin_expon_cx, scale,
        scale0;
-     int old_rm, rm_changed=0;
 
   // unpack arguments, check for NaN or Infinity
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);
 
 if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
@@ -60,8 +52,6 @@ if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {
 #endif
   res.w[1] = CX.w[1] & QUIET_MASK64;
   res.w[0] = CX.w[0];
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
     // x is Infinity?
@@ -76,8 +66,6 @@ if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
 #endif
     res.w[1] = 0x7c00000000000000ull;
     res.w[0] = 0;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 
@@ -91,8 +79,6 @@ if ((!CY.w[1]) && (!CY.w[0])) {
   // x=y=0, return NaN
   res.w[1] = 0x7c00000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 if (valid_y || ((y.w[1] & NAN_MASK64) == INFINITY_MASK64)) {
@@ -103,8 +89,6 @@ if (valid_y || ((y.w[1] & NAN_MASK64) == INFINITY_MASK64)) {
 
   res.w[1] = sign_x | (((UINT64) exponent_x) << 49);
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 }
@@ -119,8 +103,6 @@ if (!valid_y) {
 #endif
     res.w[1] = CY.w[1] & QUIET_MASK64;
     res.w[0] = CY.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is Infinity?
@@ -128,8 +110,6 @@ if (!valid_y) {
     // return x
     res.w[1] = x.w[1];
     res.w[0] = x.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0
@@ -139,8 +119,6 @@ if (!valid_y) {
 #endif
   res.w[1] = 0x7c00000000000000ull;
   res.w[0] = 0;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 
@@ -152,8 +130,6 @@ if (diff_expon <= 0) {
   if (diff_expon > 34) {
     // |x|<|y| in this case
     res = x;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // set exponent of y to exponent_x, scale coefficient_y
@@ -163,8 +139,6 @@ if (diff_expon <= 0) {
   if (P256.w[2] || P256.w[3]) {
     // |x|<|y| in this case
     res = x;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 
@@ -173,8 +147,6 @@ if (diff_expon <= 0) {
   if (__unsigned_compare_ge_128 (P256, CX2)) {
     // |x|<|y| in this case
     res = x;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 
@@ -192,8 +164,6 @@ if (diff_expon <= 0) {
   }
 
   get_BID128_very_fast (&res, sign_x, exponent_x, CR);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
   // 2^64
@@ -230,8 +200,6 @@ while (diff_expon > 0) {
   // check for remainder == 0
   if (!CX.w[1] && !CX.w[0]) {
     get_BID128_very_fast (&res, sign_x, exponent_y, CX);
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -245,7 +213,5 @@ if ((__unsigned_compare_gt_128 (CX2, CY))
 }
 
 get_BID128_very_fast (&res, sign_x, exponent_y, CX);
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
diff --git a/libgcc/config/libbid/bid128_sqrt.c b/libgcc/config/libbid/bid128_sqrt.c
old mode 100755
new mode 100644
index 577ece928876..b28038389ad1
--- a/libgcc/config/libbid/bid128_sqrt.c
+++ b/libgcc/config/libbid/bid128_sqrt.c
@@ -24,8 +24,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 #define BID_128RES
 #include "bid_internal.h"
 #include "bid_sqrt_macros.h"
-#include <fenv.h>
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
+#include <fenv.h>
+
 #define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT
 #endif
 
@@ -38,17 +39,10 @@ BID128_FUNCTION_ARG1 (bid128_sqrt, x)
      int_float fx, f64;
      int exponent_x, bin_expon_cx;
      int digits, scale, exponent_q;
-     int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
      fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
   // unpack arguments, check for NaN or Infinity
 if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
 res.w[1] = CX.w[1];
@@ -60,8 +54,6 @@ if ((x.w[1] & 0x7c00000000000000ull) == 0x7c00000000000000ull) {
     __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
   res.w[1] = CX.w[1] & QUIET_MASK64;
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
     // x is Infinity?
@@ -74,8 +66,6 @@ if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
     __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
   }
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
     // x is 0 otherwise
@@ -84,8 +74,6 @@ res.w[1] =
   sign_x |
   ((((UINT64) (exponent_x + DECIMAL_EXPONENT_BIAS_128)) >> 1) << 49);
 res.w[0] = 0;
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
 if (sign_x) {
@@ -94,8 +82,6 @@ if (sign_x) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -131,8 +117,6 @@ if (CS.w[0] * CS.w[0] == A10.w[0]) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -304,8 +288,6 @@ get_BID128_fast (&res, 0,
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
 
@@ -320,18 +302,10 @@ BID128_FUNCTION_ARGTYPE1 (bid128d_sqrt, UINT64, x)
      int_float fx, f64;
      int exponent_x, bin_expon_cx;
      int digits, scale, exponent_q;
-     int old_rm, rm_changed=0;
-
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
      fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 	// unpack arguments, check for NaN or Infinity
    // unpack arguments, check for NaN or Infinity
 CX.w[1] = 0;
@@ -347,8 +321,6 @@ if ((x & 0x7c00000000000000ull) == 0x7c00000000000000ull) {
   res.w[0] = (CX.w[0] & 0x0003ffffffffffffull);
   __mul_64x64_to_128 (res, res.w[0], power10_table_128[18].w[0]);
   res.w[1] |= ((CX.w[0]) & 0xfc00000000000000ull);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 	   // x is Infinity?
@@ -360,8 +332,6 @@ if ((x & 0x7800000000000000ull) == 0x7800000000000000ull) {
     __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
   }
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 	   // x is 0 otherwise
@@ -372,8 +342,6 @@ res.w[1] =
   sign_x | ((((UINT64) (exponent_x + DECIMAL_EXPONENT_BIAS_128)) >> 1)
 	    << 49);
 res.w[0] = 0;
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 }
 if (sign_x) {
@@ -382,8 +350,6 @@ if (sign_x) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -421,8 +387,6 @@ if (CS.w[0] * CS.w[0] == A10.w[0]) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -594,8 +558,7 @@ get_BID128_fast (&res, 0, (exponent_q + DECIMAL_EXPONENT_BIAS_128) >> 1,
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 
+
 }
diff --git a/libgcc/config/libbid/bid64_div.c b/libgcc/config/libbid/bid64_div.c
old mode 100755
new mode 100644
index 7f34556c6d61..69758482b89e
--- a/libgcc/config/libbid/bid64_div.c
+++ b/libgcc/config/libbid/bid64_div.c
@@ -55,8 +55,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "bid_internal.h"
 #include "bid_div_macros.h"
-#include <fenv.h>
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
+#include <fenv.h>
+
 #define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT
 #endif
 
@@ -64,6 +65,7 @@ extern UINT32 convert_table[5][128][2];
 extern SINT8 factors[][2];
 extern UINT8 packed_10000_zeros[];
 
+
 #if DECIMAL_CALL_BY_REFERENCE
 
 void
@@ -92,7 +94,6 @@ bid64_div (UINT64 x,
   int rmode, amount;
   int nzeros, i, j, k, d5;
   UINT32 QX32, tdigit[3], digit, digit_h, digit_low;
-  int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   fexcept_t binaryflags = 0;
 #endif
@@ -105,12 +106,6 @@ bid64_div (UINT64 x,
   y = *py;
 #endif
 
-  // Set it to round-to-nearest (if different)
-  if ((old_rm=fegetround()) != FE_TONEAREST) {
-    rm_changed=1;
-    fesetround(FE_TONEAREST);
-  }
-
   valid_x = unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x);
   valid_y = unpack_BID64 (&sign_y, &exponent_y, &coefficient_y, y);
 
@@ -128,8 +123,6 @@ bid64_div (UINT64 x,
       if ((x & SNAN_MASK64) == SNAN_MASK64)	// sNaN
 	__set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (coefficient_x & QUIET_MASK64);
     }
     // x is Infinity?
@@ -141,14 +134,10 @@ bid64_div (UINT64 x,
 #ifdef SET_STATUS_FLAGS
 	  __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-          // restore the rounding mode back if it has been changed
-          if (rm_changed) fesetround(old_rm);
 	  BID_RETURN (NAN_MASK64);
 	}
       } else {
 	// otherwise return +/-Inf
-        // restore the rounding mode back if it has been changed
-        if (rm_changed) fesetround(old_rm);
 	BID_RETURN (((x ^ y) & 0x8000000000000000ull) |
 		    INFINITY_MASK64);
       }
@@ -160,8 +149,6 @@ bid64_div (UINT64 x,
 #ifdef SET_STATUS_FLAGS
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (NAN_MASK64);
     }
     if (((y & INFINITY_MASK64) != INFINITY_MASK64)) {
@@ -176,8 +163,6 @@ bid64_div (UINT64 x,
 	exponent_x = DECIMAL_MAX_EXPON_64;
       else if (exponent_x < 0)
 	exponent_x = 0;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN ((sign_x ^ sign_y) | (((UINT64) exponent_x) << 53));
     }
 
@@ -191,23 +176,17 @@ bid64_div (UINT64 x,
       if ((y & SNAN_MASK64) == SNAN_MASK64)	// sNaN
 	__set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (coefficient_y & QUIET_MASK64);
     }
     // y is Infinity?
     if ((y & INFINITY_MASK64) == INFINITY_MASK64) {
       // return +/-0
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (((x ^ y) & 0x8000000000000000ull));
     }
     // y is 0
 #ifdef SET_STATUS_FLAGS
     __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN ((sign_x ^ sign_y) | INFINITY_MASK64);
   }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -276,8 +255,6 @@ bid64_div (UINT64 x,
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
       (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
     // get decimal digits of Q
@@ -447,8 +424,6 @@ bid64_div (UINT64 x,
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
       (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
   }
@@ -519,8 +494,6 @@ bid64_div (UINT64 x,
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   } else {
     // UF occurs
@@ -537,8 +510,6 @@ bid64_div (UINT64 x,
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
 
   }
@@ -557,17 +528,10 @@ int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,
   digits_q, amount;
 int nzeros, i, j, k, d5, done = 0;
 unsigned rmode;
-int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);
 
 	// unpack arguments, check for NaN or Infinity
@@ -581,8 +545,6 @@ if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], (x))) {
   // test if x is NaN
   if (((x) & 0x7c00000000000000ull) == 0x7c00000000000000ull) {
     res = CX.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res & QUIET_MASK64);
   }
   // x is Infinity?
@@ -595,18 +557,14 @@ if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], (x))) {
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
       res = 0x7c00000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
-    }
-    if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
-      // otherwise return +/-Inf
-      res =
-	(((x) ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
+	if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
+    // otherwise return +/-Inf
+    res =
+      (((x) ^ y.w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;
+    BID_RETURN (res);
+	}
   }
   // x is 0
   if ((y.w[1] & INFINITY_MASK64) != INFINITY_MASK64) {
@@ -616,8 +574,6 @@ if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], (x))) {
 #endif
       // x=y=0, return NaN
       res = 0x7c00000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
     // return 0
@@ -628,8 +584,6 @@ if (!unpack_BID64 (&sign_x, &exponent_x, &CX.w[0], (x))) {
     else if (exponent_x < 0)
       exponent_x = 0;
     res |= (((UINT64) exponent_x) << 53);
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -650,16 +604,12 @@ if (!valid_y) {
     amount = recip_scale[18];
     __shr_128 (Tmp, Qh, amount);
     res = (CY.w[1] & 0xfc00000000000000ull) | Tmp.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is Infinity?
   if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
     // return +/-0
     res = sign_x ^ sign_y;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0, return +/-Inf
@@ -668,8 +618,6 @@ if (!valid_y) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -732,8 +680,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
       (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
 
@@ -870,17 +816,15 @@ if (!done) {
 
       }
     }
-    if(diff_expon>=0){
-      res =
-	fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],
-				 rnd_mode, pfpsf);
+	if(diff_expon>=0){
+    res =
+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],
+			       rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
-    }
+    BID_RETURN (res);
+	}
   }
 #endif
 
@@ -961,8 +905,6 @@ if (!done) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   } else {
     // UF occurs
@@ -979,9 +921,8 @@ if (!done) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
+
   }
 
 }
@@ -1001,18 +942,10 @@ int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,
   digits_q, amount;
 int nzeros, i, j, k, d5, done = 0;
 unsigned rmode;
-int old_rm, rm_changed=0;
-
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 valid_y = unpack_BID64 (&sign_y, &exponent_y, &CY.w[0], (y));
 
 	// unpack arguments, check for NaN or Infinity
@@ -1031,9 +964,7 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
       amount = recip_scale[18];
       __shr_128 (Tmp, Qh, amount);
       res = (CX.w[1] & 0xfc00000000000000ull) | Tmp.w[0];
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
+    BID_RETURN (res);
   }
   // x is Infinity?
   if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
@@ -1045,18 +976,14 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
       res = 0x7c00000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
-    }
-    if (((y & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
-      // otherwise return +/-Inf
-      res =
-	((x.w[1] ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
+	if (((y & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
+    // otherwise return +/-Inf
+    res =
+      ((x.w[1] ^ (y)) & 0x8000000000000000ull) | 0x7800000000000000ull;
+    BID_RETURN (res);
+	}
   }
   // x is 0
   if (((y & INFINITY_MASK64) != INFINITY_MASK64) &&
@@ -1066,21 +993,17 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
 #endif
     // x=y=0, return NaN
     res = 0x7c00000000000000ull;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // return 0
   if (((y & 0x7800000000000000ull) != 0x7800000000000000ull)) {
-    if (!CY.w[0]) {
+	  if (!CY.w[0]) {
 #ifdef SET_STATUS_FLAGS
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
       res = 0x7c00000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
-    }
+	  }
     exponent_x =
       exponent_x - exponent_y - DECIMAL_EXPONENT_BIAS_128 +
       (DECIMAL_EXPONENT_BIAS << 1);
@@ -1089,8 +1012,6 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
     else if (exponent_x < 0)
       exponent_x = 0;
     res = (sign_x ^ sign_y) | (((UINT64) exponent_x) << 53);
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 }
@@ -1104,16 +1025,12 @@ if (!valid_y) {
     if ((y & SNAN_MASK64) == SNAN_MASK64)	// sNaN
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (CY.w[0] & QUIET_MASK64);
   }
   // y is Infinity?
   if (((y) & 0x7800000000000000ull) == 0x7800000000000000ull) {
     // return +/-0
     res = sign_x ^ sign_y;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0, return +/-Inf
@@ -1122,8 +1039,6 @@ if (!valid_y) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -1188,8 +1103,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
       (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
 
@@ -1246,104 +1159,102 @@ if (!done) {
 #endif
 #ifndef LEAVE_TRAILING_ZEROS
     // check whether result is exact
-    {
-      if(!done) {
-	// check whether CX, CY are short
-	if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {
-	  i = (int) CY.w[0] - 1;
-	  j = (int) CX.w[0] - 1;
-	  // difference in powers of 2 factors for Y and X
-	  nzeros = ed2 - factors[i][0] + factors[j][0];
-	  // difference in powers of 5 factors
-	  d5 = ed2 - factors[i][1] + factors[j][1];
-	  if (d5 < nzeros)
-	    nzeros = d5;
+  {
+	  if(!done) {
+    // check whether CX, CY are short
+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {
+      i = (int) CY.w[0] - 1;
+      j = (int) CX.w[0] - 1;
+      // difference in powers of 2 factors for Y and X
+      nzeros = ed2 - factors[i][0] + factors[j][0];
+      // difference in powers of 5 factors
+      d5 = ed2 - factors[i][1] + factors[j][1];
+      if (d5 < nzeros)
+		nzeros = d5;
+      // get P*(2^M[extra_digits])/10^extra_digits
+      __mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];
+
+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
+      amount = recip_scale[nzeros];
+      __shr_128_long (CQ, Qh, amount);
+
+      diff_expon += nzeros;
+    } else {
+      // decompose Q as Qh*10^17 + Ql
+      //T128 = reciprocals10_128[17];
+      Q_low = CQ.w[0];
+
+      {
+	tdigit[0] = Q_low & 0x3ffffff;
+	tdigit[1] = 0;
+	QX = Q_low >> 26;
+	QX32 = QX;
+	nzeros = 0;
+
+	for (j = 0; QX32; j++, QX32 >>= 7) {
+	  k = (QX32 & 127);
+	  tdigit[0] += convert_table[j][k][0];
+	  tdigit[1] += convert_table[j][k][1];
+	  if (tdigit[0] >= 100000000) {
+	    tdigit[0] -= 100000000;
+	    tdigit[1]++;
+	  }
+	}
+
+	if (tdigit[1] >= 100000000) {
+	  tdigit[1] -= 100000000;
+	  if (tdigit[1] >= 100000000)
+	    tdigit[1] -= 100000000;
+	}
+
+	digit = tdigit[0];
+	if (!digit && !tdigit[1])
+	  nzeros += 16;
+	else {
+	  if (!digit) {
+	    nzeros += 8;
+	    digit = tdigit[1];
+	  }
+	  // decompose digit
+	  PD = (UINT64) digit *0x068DB8BBull;
+	  digit_h = (UINT32) (PD >> 40);
+	  digit_low = digit - digit_h * 10000;
+
+	  if (!digit_low)
+	    nzeros += 4;
+	  else
+	    digit_h = digit_low;
+
+	  if (!(digit_h & 1))
+	    nzeros +=
+	      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>
+			    (digit_h & 7));
+	}
+
+	if (nzeros) {
 	  // get P*(2^M[extra_digits])/10^extra_digits
 	  __mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
-	  //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];
 
 	  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
 	  amount = recip_scale[nzeros];
-	  __shr_128_long (CQ, Qh, amount);
-
-	  diff_expon += nzeros;
-	} else {
-	  // decompose Q as Qh*10^17 + Ql
-	  //T128 = reciprocals10_128[17];
-	  Q_low = CQ.w[0];
-
-	  {
-	    tdigit[0] = Q_low & 0x3ffffff;
-	    tdigit[1] = 0;
-	    QX = Q_low >> 26;
-	    QX32 = QX;
-	    nzeros = 0;
-
-	    for (j = 0; QX32; j++, QX32 >>= 7) {
-	      k = (QX32 & 127);
-	      tdigit[0] += convert_table[j][k][0];
-	      tdigit[1] += convert_table[j][k][1];
-	      if (tdigit[0] >= 100000000) {
-		tdigit[0] -= 100000000;
-		tdigit[1]++;
-	      }
-	    }
-
-	    if (tdigit[1] >= 100000000) {
-	      tdigit[1] -= 100000000;
-	      if (tdigit[1] >= 100000000)
-		tdigit[1] -= 100000000;
-	    }
-
-	    digit = tdigit[0];
-	    if (!digit && !tdigit[1])
-	      nzeros += 16;
-	    else {
-	      if (!digit) {
-		nzeros += 8;
-		digit = tdigit[1];
-	      }
-	      // decompose digit
-	      PD = (UINT64) digit *0x068DB8BBull;
-	      digit_h = (UINT32) (PD >> 40);
-	      digit_low = digit - digit_h * 10000;
-
-	      if (!digit_low)
-		nzeros += 4;
-	      else
-		digit_h = digit_low;
-
-	      if (!(digit_h & 1))
-		nzeros +=
-		  3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>
-				(digit_h & 7));
-	    }
-	
-	    if (nzeros) {
-	      // get P*(2^M[extra_digits])/10^extra_digits
-	      __mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
-
-	      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
-	      amount = recip_scale[nzeros];
-	      __shr_128 (CQ, Qh, amount);
-	    }
-	    diff_expon += nzeros;
-
-	  }
+	  __shr_128 (CQ, Qh, amount);
 	}
+	diff_expon += nzeros;
+
       }
-      if(diff_expon>=0){
-	res =
-	  fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],
-				   rnd_mode, pfpsf);
+    }
+	  }
+	if(diff_expon>=0){
+    res =
+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],
+			       rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
-	(void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-        // restore the rounding mode back if it has been changed
-	if (rm_changed) fesetround(old_rm);
-	BID_RETURN (res);
-      }
-    }
+    BID_RETURN (res);
+	}
+  }
 #endif
 
   if (diff_expon >= 0) {
@@ -1426,8 +1337,6 @@ if (!done) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   } else {
     // UF occurs
@@ -1444,9 +1353,8 @@ if (!done) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
+
   }
 
 }
@@ -1471,17 +1379,10 @@ int exponent_x, exponent_y, bin_index, bin_expon, diff_expon, ed2,
   digits_q, amount;
 int nzeros, i, j, k, d5, done = 0;
 unsigned rmode;
-int old_rm, rm_changed=0;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 fexcept_t binaryflags = 0;
 #endif
 
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
-
 valid_y = unpack_BID128_value (&sign_y, &exponent_y, &CY, y);
 
 	// unpack arguments, check for NaN or Infinity
@@ -1500,9 +1401,7 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
       amount = recip_scale[18];
       __shr_128 (Tmp, Qh, amount);
       res = (CX.w[1] & 0xfc00000000000000ull) | Tmp.w[0];
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
+    BID_RETURN (res);
   }
   // x is Infinity?
   if ((x.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
@@ -1514,19 +1413,15 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
       res = 0x7c00000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
-    }
-    if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
-      // otherwise return +/-Inf
-      res =
-	((x.w[1] ^ y.
-	  w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
+	if (((y.w[1] & 0x7c00000000000000ull) != 0x7c00000000000000ull)) {
+    // otherwise return +/-Inf
+    res =
+      ((x.w[1] ^ y.
+	w[1]) & 0x8000000000000000ull) | 0x7800000000000000ull;
+    BID_RETURN (res);
+	}
   }
   // x is 0
   if (((y.w[1] & 0x7800000000000000ull) != 0x7800000000000000ull)) {
@@ -1536,8 +1431,6 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
 #endif
     // x=y=0, return NaN
     res = 0x7c00000000000000ull;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // return 0
@@ -1548,8 +1441,6 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
   else if (exponent_x < 0)
     exponent_x = 0;
   res |= (((UINT64) exponent_x) << 53);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
   }
 }
@@ -1569,16 +1460,12 @@ if (!valid_y) {
       amount = recip_scale[18];
       __shr_128 (Tmp, Qh, amount);
       res = (CY.w[1] & 0xfc00000000000000ull) | Tmp.w[0];
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
+    BID_RETURN (res);
   }
   // y is Infinity?
   if ((y.w[1] & 0x7800000000000000ull) == 0x7800000000000000ull) {
     // return +/-0
     res = sign_x ^ sign_y;
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // y is 0, return +/-Inf
@@ -1587,8 +1474,6 @@ if (!valid_y) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, ZERO_DIVIDE_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -1651,8 +1536,6 @@ if (__unsigned_compare_gt_128 (CY, CX)) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
       (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
 
@@ -1711,102 +1594,100 @@ if (!done) {
 #ifndef LEAVE_TRAILING_ZEROS
     // check whether result is exact
   {
-    if(!done) {
-      // check whether CX, CY are short
-      if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {
-	i = (int) CY.w[0] - 1;
-	j = (int) CX.w[0] - 1;
-	// difference in powers of 2 factors for Y and X
-	nzeros = ed2 - factors[i][0] + factors[j][0];
-	// difference in powers of 5 factors
-	d5 = ed2 - factors[i][1] + factors[j][1];
-	if (d5 < nzeros)
-	  nzeros = d5;
-	// get P*(2^M[extra_digits])/10^extra_digits
-	__mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
-	//__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];
-	
-	// now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
-	amount = recip_scale[nzeros];
-	__shr_128_long (CQ, Qh, amount);
-	
-	diff_expon += nzeros;
-      } else {
-	// decompose Q as Qh*10^17 + Ql
-	//T128 = reciprocals10_128[17];
-	Q_low = CQ.w[0];
-      
-	{
-	  tdigit[0] = Q_low & 0x3ffffff;
-	  tdigit[1] = 0;
-	  QX = Q_low >> 26;
-	  QX32 = QX;
-	  nzeros = 0;
-
-	  for (j = 0; QX32; j++, QX32 >>= 7) {
-	    k = (QX32 & 127);
-	    tdigit[0] += convert_table[j][k][0];
-	    tdigit[1] += convert_table[j][k][1];
-	    if (tdigit[0] >= 100000000) {
-	      tdigit[0] -= 100000000;
-	      tdigit[1]++;
-	    }
+	  if(!done) {
+    // check whether CX, CY are short
+    if (!CX.w[1] && !CY.w[1] && (CX.w[0] <= 1024) && (CY.w[0] <= 1024)) {
+      i = (int) CY.w[0] - 1;
+      j = (int) CX.w[0] - 1;
+      // difference in powers of 2 factors for Y and X
+      nzeros = ed2 - factors[i][0] + factors[j][0];
+      // difference in powers of 5 factors
+      d5 = ed2 - factors[i][1] + factors[j][1];
+      if (d5 < nzeros)
+	nzeros = d5;
+      // get P*(2^M[extra_digits])/10^extra_digits
+      __mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
+      //__mul_128x128_to_256(P256, CQ, reciprocals10_128[nzeros]);Qh.w[1]=P256.w[3];Qh.w[0]=P256.w[2];
+
+      // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
+      amount = recip_scale[nzeros];
+      __shr_128_long (CQ, Qh, amount);
+
+      diff_expon += nzeros;
+    } else {
+      // decompose Q as Qh*10^17 + Ql
+      //T128 = reciprocals10_128[17];
+      Q_low = CQ.w[0];
+
+      {
+	tdigit[0] = Q_low & 0x3ffffff;
+	tdigit[1] = 0;
+	QX = Q_low >> 26;
+	QX32 = QX;
+	nzeros = 0;
+
+	for (j = 0; QX32; j++, QX32 >>= 7) {
+	  k = (QX32 & 127);
+	  tdigit[0] += convert_table[j][k][0];
+	  tdigit[1] += convert_table[j][k][1];
+	  if (tdigit[0] >= 100000000) {
+	    tdigit[0] -= 100000000;
+	    tdigit[1]++;
 	  }
+	}
 
-	  if (tdigit[1] >= 100000000) {
+	if (tdigit[1] >= 100000000) {
+	  tdigit[1] -= 100000000;
+	  if (tdigit[1] >= 100000000)
 	    tdigit[1] -= 100000000;
-	    if (tdigit[1] >= 100000000)
-	      tdigit[1] -= 100000000;
-	  }
+	}
 
-	  digit = tdigit[0];
-	  if (!digit && !tdigit[1])
-	    nzeros += 16;
-	  else {
-	    if (!digit) {
-	      nzeros += 8;
-	      digit = tdigit[1];
-	    }
-	    // decompose digit
-	    PD = (UINT64) digit *0x068DB8BBull;
-	    digit_h = (UINT32) (PD >> 40);
-	    digit_low = digit - digit_h * 10000;
-
-	    if (!digit_low)
-	      nzeros += 4;
-	    else
-	      digit_h = digit_low;
-
-	    if (!(digit_h & 1))
-	      nzeros +=
-		3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>
-			      (digit_h & 7));
+	digit = tdigit[0];
+	if (!digit && !tdigit[1])
+	  nzeros += 16;
+	else {
+	  if (!digit) {
+	    nzeros += 8;
+	    digit = tdigit[1];
 	  }
+	  // decompose digit
+	  PD = (UINT64) digit *0x068DB8BBull;
+	  digit_h = (UINT32) (PD >> 40);
+	  digit_low = digit - digit_h * 10000;
+
+	  if (!digit_low)
+	    nzeros += 4;
+	  else
+	    digit_h = digit_low;
 
-	  if (nzeros) {
-	    // get P*(2^M[extra_digits])/10^extra_digits
-	    __mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
+	  if (!(digit_h & 1))
+	    nzeros +=
+	      3 & (UINT32) (packed_10000_zeros[digit_h >> 3] >>
+			    (digit_h & 7));
+	}
 
-	    // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
-	    amount = recip_scale[nzeros];
-	    __shr_128 (CQ, Qh, amount);
-	  }
-	  diff_expon += nzeros;
+	if (nzeros) {
+	  // get P*(2^M[extra_digits])/10^extra_digits
+	  __mul_128x128_high (Qh, CQ, reciprocals10_128[nzeros]);
 
+	  // now get P/10^extra_digits: shift Q_high right by M[extra_digits]-128
+	  amount = recip_scale[nzeros];
+	  __shr_128 (CQ, Qh, amount);
 	}
+	diff_expon += nzeros;
+
       }
     }
-    if(diff_expon>=0){
-      res =
-	fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],
-				 rnd_mode, pfpsf);
+	  }
+	if(diff_expon>=0){
+    res =
+      fast_get_BID64_check_OF (sign_x ^ sign_y, diff_expon, CQ.w[0],
+			       rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
-      (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
+    (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
-      BID_RETURN (res);
-    }
+    BID_RETURN (res);
+	}
   }
 #endif
 
@@ -1891,8 +1772,6 @@ if (!done) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   } else {
     // UF occurs
@@ -1909,9 +1788,8 @@ if (!done) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
+
   }
 
 }
diff --git a/libgcc/config/libbid/bid64_sqrt.c b/libgcc/config/libbid/bid64_sqrt.c
old mode 100755
new mode 100644
index 6309c425e811..29f4cf1f819f
--- a/libgcc/config/libbid/bid64_sqrt.c
+++ b/libgcc/config/libbid/bid64_sqrt.c
@@ -41,8 +41,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
 
 #include "bid_internal.h"
 #include "bid_sqrt_macros.h"
-#include <fenv.h>
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
+#include <fenv.h>
+
 #define FE_ALL_FLAGS FE_INVALID|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW|FE_INEXACT
 #endif
 
@@ -72,8 +73,6 @@ bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM
   int exponent_x, exponent_q, bin_expon_cx;
   int digits_x;
   int scale;
-  int old_rm, rm_changed=0;
-
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   fexcept_t binaryflags = 0;
 #endif
@@ -85,12 +84,6 @@ bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM
   x = *px;
 #endif
 
-  // Set it to round-to-nearest (if different)
-  if ((old_rm=fegetround()) != FE_TONEAREST) {
-    rm_changed=1;
-    fesetround(FE_TONEAREST);
-  }
-  
   // unpack arguments, check for NaN or Infinity
   if (!unpack_BID64 (&sign_x, &exponent_x, &coefficient_x, x)) {
     // x is Inf. or NaN or 0
@@ -107,15 +100,11 @@ bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM
       if ((x & SNAN_MASK64) == SNAN_MASK64)	// sNaN
 	__set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res & QUIET_MASK64);
     }
     // x is 0
     exponent_x = (exponent_x + DECIMAL_EXPONENT_BIAS) >> 1;
     res = sign_x | (((UINT64) exponent_x) << 53);
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // x<0?
@@ -124,8 +113,6 @@ bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM
 #ifdef SET_STATUS_FLAGS
     __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -154,8 +141,6 @@ bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
     (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // if exponent is odd, scale coefficient by 10
@@ -221,8 +206,6 @@ bid64_sqrt (UINT64 x _RND_MODE_PARAM _EXC_FLAGS_PARAM
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
   (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 
@@ -240,13 +223,6 @@ int digits, scale, exponent_q = 0, exact = 1, amount, extra_digits;
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 fexcept_t binaryflags = 0;
 #endif
-int old_rm, rm_changed=0;
-
-// Set it to round-to-nearest (if different)
-if ((old_rm=fegetround()) != FE_TONEAREST) {
-  rm_changed=1;
-  fesetround(FE_TONEAREST);
-}
 
 	// unpack arguments, check for NaN or Infinity
 if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
@@ -264,8 +240,6 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
     amount = recip_scale[18];
     __shr_128 (Tmp, Qh, amount);
     res = (CX.w[1] & 0xfc00000000000000ull) | Tmp.w[0];
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // x is Infinity?
@@ -277,8 +251,6 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
       __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
     }
-    // restore the rounding mode back if it has been changed
-    if (rm_changed) fesetround(old_rm);
     BID_RETURN (res);
   }
   // x is 0 otherwise
@@ -292,8 +264,6 @@ if (!unpack_BID128_value (&sign_x, &exponent_x, &CX, x)) {
     exponent_x = DECIMAL_MAX_EXPON_64;
   //res= sign_x | (((UINT64)exponent_x)<<53);
   res = get_BID64 (sign_x, exponent_x, 0, rnd_mode, pfpsf);
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 if (sign_x) {
@@ -301,8 +271,6 @@ if (sign_x) {
 #ifdef SET_STATUS_FLAGS
   __set_status_flags (pfpsf, INVALID_EXCEPTION);
 #endif
-  // restore the rounding mode back if it has been changed
-  if (rm_changed) fesetround(old_rm);
   BID_RETURN (res);
 }
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
@@ -344,8 +312,6 @@ if (CS.w[0] < 10000000000000000ull) {
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
       (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-      // restore the rounding mode back if it has been changed
-      if (rm_changed) fesetround(old_rm);
       BID_RETURN (res);
     }
   }
@@ -580,8 +546,7 @@ res = get_BID64 (0, exponent_q, CS.w[0], rnd_mode, pfpsf);
 #ifdef UNCHANGED_BINARY_STATUS_FLAGS
 (void) fesetexceptflag (&binaryflags, FE_ALL_FLAGS);
 #endif
-// restore the rounding mode back if it has been changed
-if (rm_changed) fesetround(old_rm);
 BID_RETURN (res);
 
+
 }

base-commit: 78d19ea3fea308a08d2844de88d43154465daa78
-- 
2.51.0

